name: Auto Blog from Commit

on:
  push:
    branches:
      - main
      - master

jobs:
  generate-blog:
    if: contains(github.event.head_commit.message, '[blog]')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Get commit diff
        id: diff
        run: |
          git diff HEAD~1 HEAD --no-color > /tmp/commit_diff.txt 2>/dev/null || git show HEAD --no-color > /tmp/commit_diff.txt
          git diff --name-only HEAD~1 HEAD > /tmp/files_changed.txt 2>/dev/null || git show --name-only --format="" HEAD > /tmp/files_changed.txt

      - name: Generate and publish blog post
        env:
          DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          INK_AND_CODE_TOKEN: ${{ secrets.INK_AND_CODE_TOKEN }}
          INK_AND_CODE_URL: ${{ secrets.INK_AND_CODE_URL }}
          COMMIT_MSG: ${{ github.event.head_commit.message }}
          COMMIT_SHA: ${{ github.sha }}
          COMMIT_URL: ${{ github.event.head_commit.url }}
          REPO_NAME: ${{ github.repository }}
        run: |
          DIFF=$(cat /tmp/commit_diff.txt | head -c 8000)
          FILES=$(cat /tmp/files_changed.txt)
          
          # Build prompt (no indentation to avoid AI copying it)
          read -r -d '' PROMPT << 'PROMPT_END'
You are a technical blog writer. Write a blog post in Chinese based on this Git commit.

Repository: REPO_PLACEHOLDER
Commit: MSG_PLACEHOLDER
Files changed:
FILES_PLACEHOLDER

Diff (truncated):
DIFF_PLACEHOLDER

Requirements:
1. Write an attractive Chinese title (no quotes)
2. Use Markdown format, start content directly (no leading spaces or >)
3. Include: background, implementation details, code explanation, summary
4. 800-1500 words in Chinese
5. Output EXACTLY in this format (no extra spaces before markers):

---TITLE---
文章标题
---CONTENT---
## 背景

正文内容...

## 实现

代码说明...

## 总结

总结内容...
---TAGS---
标签1,标签2,标签3
PROMPT_END
          # Replace placeholders
          PROMPT="${PROMPT//REPO_PLACEHOLDER/$REPO_NAME}"
          PROMPT="${PROMPT//MSG_PLACEHOLDER/$COMMIT_MSG}"
          PROMPT="${PROMPT//FILES_PLACEHOLDER/$FILES}"
          PROMPT="${PROMPT//DIFF_PLACEHOLDER/$DIFF}"

          ESCAPED_PROMPT=$(echo "$PROMPT" | jq -Rs .)
          
          # Call AI API
          if [ -n "$DEEPSEEK_API_KEY" ]; then
            echo "Using DeepSeek API..."
            RESPONSE=$(curl -s https://api.deepseek.com/v1/chat/completions \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $DEEPSEEK_API_KEY" \
              -d "{\"model\":\"deepseek-chat\",\"max_tokens\":4096,\"messages\":[{\"role\":\"user\",\"content\":$ESCAPED_PROMPT}]}")
            GENERATED=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty')
          elif [ -n "$ANTHROPIC_API_KEY" ]; then
            echo "Using Claude API..."
            RESPONSE=$(curl -s https://api.anthropic.com/v1/messages \
              -H "Content-Type: application/json" \
              -H "x-api-key: $ANTHROPIC_API_KEY" \
              -H "anthropic-version: 2023-06-01" \
              -d "{\"model\":\"claude-sonnet-4-20250514\",\"max_tokens\":4096,\"messages\":[{\"role\":\"user\",\"content\":$ESCAPED_PROMPT}]}")
            GENERATED=$(echo "$RESPONSE" | jq -r '.content[0].text // empty')
          elif [ -n "$OPENAI_API_KEY" ]; then
            echo "Using OpenAI API..."
            RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -d "{\"model\":\"gpt-4o\",\"max_tokens\":4096,\"messages\":[{\"role\":\"user\",\"content\":$ESCAPED_PROMPT}]}")
            GENERATED=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty')
          else
            echo "Error: No AI API key provided"
            exit 1
          fi
          
          if [ -z "$GENERATED" ]; then
            echo "Error: AI generation failed"
            echo "Response: $RESPONSE"
            exit 1
          fi
          
          echo "AI Response received, parsing..."
          echo "$GENERATED" > /tmp/ai_output.txt
          
          # Parse output to separate files (avoid shell expansion issues)
          awk '/---TITLE---/{flag=1; next} /---CONTENT---/{flag=0} flag' /tmp/ai_output.txt | tr -d '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > /tmp/title.txt
          awk '/---CONTENT---/{flag=1; next} /---TAGS---/{flag=0} flag' /tmp/ai_output.txt > /tmp/content.txt
          awk '/---TAGS---/{flag=1; next} flag' /tmp/ai_output.txt | tr -d '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > /tmp/tags.txt
          
          TITLE=$(cat /tmp/title.txt)
          TAGS=$(cat /tmp/tags.txt)
          
          echo "Title: $TITLE"
          echo "Tags: $TAGS"
          
          if [ -z "$TITLE" ] || [ ! -s /tmp/content.txt ]; then
            echo "Error: Failed to parse AI output"
            echo "Raw output:"
            cat /tmp/ai_output.txt
            exit 1
          fi
          
          # Build JSON payload using jq with file input for content
          jq -n \
            --arg title "$TITLE" \
            --rawfile content /tmp/content.txt \
            --arg tags "$TAGS" \
            --arg repo "$REPO_NAME" \
            --arg sha "$COMMIT_SHA" \
            --arg msg "$COMMIT_MSG" \
            --arg url "$COMMIT_URL" \
            '{
              title: $title,
              content: $content,
              tags: ($tags | split(",") | map(gsub("^\\s+|\\s+$"; ""))),
              published: false,
              commitInfo: {
                repo: $repo,
                sha: $sha,
                message: $msg,
                url: $url
              }
            }' > /tmp/payload.json
          
          # Debug: show payload
          echo "=== Payload Preview ==="
          cat /tmp/payload.json | head -c 1000
          echo ""
          echo "========================"
          
          # Send to blog API (with -L to follow redirects)
          echo "Publishing to ${INK_AND_CODE_URL}/api/article/create-from-commit ..."
          RESULT=$(curl -sL -w "\n%{http_code}" -X POST "${INK_AND_CODE_URL}/api/article/create-from-commit" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $INK_AND_CODE_TOKEN" \
            -d @/tmp/payload.json)
          
          # Extract HTTP status code (last line)
          HTTP_CODE=$(echo "$RESULT" | tail -n1)
          BODY=$(echo "$RESULT" | sed '$d')
          
          echo "HTTP Status: $HTTP_CODE"
          echo "API Response: $BODY"
          
          # Check if response is valid JSON
          if ! echo "$BODY" | jq -e . > /dev/null 2>&1; then
            echo "Error: API returned invalid JSON"
            echo "Raw response:"
            echo "$BODY"
            exit 1
          fi
          
          CODE=$(echo "$BODY" | jq -r '.code // 500')
          if [ "$CODE" != "201" ]; then
            echo "Failed to publish"
            echo "Error: $(echo "$BODY" | jq -r '.message // "Unknown error"')"
            exit 1
          fi
          
          ARTICLE_URL=$(echo "$BODY" | jq -r '.data.url // "N/A"')
          echo ""
          echo "=========================================="
          echo "Blog post created successfully!"
          echo "Title: $TITLE"
          echo "URL: $ARTICLE_URL"
          echo "=========================================="
